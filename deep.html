<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- <script>
      // Check if the user is logged in by verifying the accessToken
      window.onload = function() {
          const accessToken = localStorage.getItem('accessToken');
          if (!accessToken) {
              // Redirect to login page if accessToken is not found
              window.location.href = 'home.html';
          }
      };
  </script> -->
  <script src="auth.js"></script>
<script src="logo.js"></script>

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="/static/lims.png"> 
    <title>Sentinel Hub Viewer</title>
    

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css" />
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

<!-- Leaflet CSS -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.css" />
<!-- Leaflet Control Geocoder CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css" />

<!-- Leaflet JS -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.js"></script>
<!-- Leaflet Control Geocoder JS -->
<script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>
<!-- Leaflet Draw JS -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
<!-- Turf JS -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/Turf.js/7.0.0-alpha.111/turf.min.js"></script>

      <link rel="stylesheet" href="styles/search.css">



    <style>
        #map {
        position: relative;
        top: 0;
        left: 0;
        height: 100vh;
        width: 100vw;
        z-index: 0;
    }
       
        #loadingIndicator {
            display: none;
            margin-top: 10px;
            color: #666;
        }
     
       
        .logo-container {
            position: fixed;
            top: 5px;
            right: 1px;
            z-index: 1000; /* Ensure it stays on top of the map */
        }
        .map-logo {
            height: 80px;
            width: auto;
            cursor: pointer;
            right: 1px;
            
        }
          /* Update these CSS styles */
          .image-controls {
            position: absolute;
            left: 60px;
            z-index: 1000;
            background: white;
            border-radius: 4px;
            padding: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            width: 190px;
            margin-top: 80px;
        }
      
    
        .control-panel {
            background: white;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
    
        #toggleControls {
            width: 170px;
            padding: 10px 15px;
            background: #28a745;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
    
        #toggleControls.active {
            background: #28a745;
            border-radius: 4px 4px 0 0;
        }

        .control-btn {
                width: 100% !important;
    height: 48px !important;
    padding: 12px 16px !important;
    margin-bottom: 8px !important;
    border: none !important;
    border-radius: 6px !important;
    font-size: 14px !important;
    font-weight: 500 !important;
    cursor: pointer !important;
    transition: all 0.3s ease !important;
    display: flex !important;
    align-items: center !important;
    justify-content: center !important;
    box-sizing: border-box !important;
    min-width: 120px !important;
   
}
    
        .control-group {
                 width: 100%;
    margin-bottom: 8px;
    display: block;
        }
        .control-group .control-btn {
    width: 100% !important;
    margin-bottom: 0 !important;
}

    
        .control-group:first-child {
            margin-top: 15px;
        }
    
        .control-group:last-child {
            margin-bottom: 15px;
        }

        /* Button styling */
.btn-success.control-btn {
    background-color: #16a34a !important;
    color: white !important;
    border: 1px solid #16a34a !important;
}

.btn-success.control-btn:hover {
    background-color: #15803d !important;
    border-color: #15803d !important;
    transform: translateY(-1px) !important;
    box-shadow: 0 4px 8px rgba(22, 163, 74, 0.2) !important;
}

.btn-success.control-btn:active {
    transform: translateY(0) !important;
    box-shadow: 0 2px 4px rgba(22, 163, 74, 0.2) !important;
}

/* Mobile responsive */
@media (max-width: 768px) {
    .control-btn {
        height: 44px !important;
        font-size: 13px !important;
        padding: 10px 14px !important;
    }
}

@media (max-width: 480px) {
    .control-btn {
        height: 40px !important;
        font-size: 12px !important;
        padding: 8px 12px !important;
    }
}
    
        #resetControls {
            margin-bottom: 15px;
            width: 100%;
        }
    
        /* Add these styles to your existing CSS */
        #toggleControls:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: #cccccc;
        }
    
        .control-panel input[type="range"]:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
    
        #resetControls:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: #cccccc;
        }
    
        /* Update the transition for smoother enabling/disabling */
        .image-controls {
            transition: opacity 0.3s ease;
        }
    
        .image-controls.disabled {
            opacity: 0.7;
            pointer-events: none;
        }

        .leaflet-touch .leaflet-draw-toolbar .leaflet-draw-edit-edit.leaflet-disabled {
    background-position: -210px -1px;
    display: none;
}
.leaflet-touch .leaflet-draw-toolbar .leaflet-draw-edit-remove.leaflet-disabled {
    background-position: -240px -2px;
    display: none;
}
.leaflet-right .leaflet-control {
    margin-right: 10px;
}


.app-container {
  width: 100%;
  height: 100vh;
  display: flex;
  flex-direction: column;
}

.main-content {
  flex: 1;
  display: flex;
  flex-direction: column;
  position: relative;
}

/* Header Styles */
.header {
            height: 70px;
            background: rgba(255, 255, 255, 0.95);
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 1000;
}

.back-button {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 40px;
  height: 40px;
  border: none;
  border-radius: 50%;
  color: black;
  font-size: 16px;
  cursor: pointer;
}

.back-button:hover {
  background-color: #2980b9;
  transform: scale(1.05);
}

.back-button:active {
  transform: scale(0.95);
}

.header-content {
      max-width: 1400px;
      margin: 0 auto;
      display: flex;
      align-items: center;

    padding: 0 20px;
    justify-content: space-between;
   
}


.logo-container {
  position: absolute;
  top: 140px;
  right: 10px;
  z-index: 999;
}

.map-logo {
  height: 40px;
  width: auto;
  border-radius: 6px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
}


/* Responsive Design */
@media (max-width: 768px) {
  .header {
    padding: 10px 15px;
    min-height: 100px;
    flex-direction: row;
    gap: 10px;
  }

  .header-content {
    width: 100%;
  }

 
}

@media (max-width: 480px) {
  .header {
    min-height: 70px;
    padding: 8px 10px;
  }


}


/* Animations */
@keyframes fadeIn {
  from {
    opacity: 0;
    transform: translateY(-10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.header {
  animation: fadeIn 0.5s ease-out;
}

    </style>
   
</head>
<body>
 <div class="app-container">
        <div class="main-content">
            <header class="header">
                <button class="back-button" onclick="goBack()">
                    <i class="fas fa-arrow-left"></i>
                </button>
                
<div class="header-content" style="display: flex; align-items: center; justify-content: space-between; flex-wrap: wrap; margin-left: 100px;"> <!-- margin-left to offset go back button -->

    <!-- Two Logos -->
    <div class="header-logo" style="display: flex; align-items: center; gap: 15px;">
        <img src="Assets/lims.png" alt="Logo" style="height: 65px; width: auto; border-radius: 8px;">
   <img id="portalLogo" style="height: 45px; width: auto; border-radius: 8px; display: none;">
<!-- <span id="portalName" style="font-size: 22px; font-weight: bold; color: #10b981;"></span> -->
    </div>

   
  </div>
           
            </header>

            <div id="map"></div>
            
          
            
            <div class="controls" style="display: none;">
                <div id="loadingIndicator">Processing...</div>
            </div>

            <div class="image-controls">
                <button id="toggleControls" class="button">Menu</button>
               
                <div id="controlPanel" class="control-panel">
                    <div class="control-group">
                        <select id="dateDropdown" class="form-select" aria-label="Select a date">
                            <option value="" disabled selected>Select a date</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label>Brightness <span id="brightnessValue" class="control-value"></span></label>
                        <input type="range" id="brightness" min="1" max="10" step="0.1" value="1.0" class="range-input">
                    </div>
                    
                    <div class="control-group">
                        <label>Contrast <span id="contrastValue" class="control-value"></span></label>
                        <input type="range" id="contrast" min="0" max="3" step="0.1" value="1.0" class="range-input">
                    </div>
                   
                    <div class="control-group">
                        <label>Histogram Equalizer <span id="equalizerValue" class="control-value"></span></label>
                        <input type="range" id="equalizer" min="1" max="50" step="1" value="0" class="range-input">
                    </div>
                    
                    <div class="control-group">
                        <button id="toggleImage" class="btn btn-success control-btn">
                            Compare
                        </button>
                    </div>
                    <button id="resetControls" class="btn btn-success control-btn">
                        Reset
                    </button>
                </div>
            </div>
        </div>
    </div>
    

    <canvas id="imageCanvas" style="display: none;"></canvas>

  
    <script>

function goBack() {
  // Check if there's a history to go back to
  if (window.history.length > 1) {
    window.history.back()
  } else {
    window.location.href = "map.html" // Change this to your desired default landing page
  }
}

                const MAPBOX_ACCESS_TOKEN = "pk.eyJ1IjoiaXFyYS0xMiIsImEiOiJjbTBsejNzencwYmhmMmpzOGo2YjBscWx0In0.uVZ01016jRsllcutrQASow";

        // Initialize variables
        client_id = "d0f90559-c9ac-45e7-9f45-a0cedcaade37"
        client_secret = "8UYn76ELTfru5o4CLhYlKYNCnu90wf6F"
        const tokenUrl = 'https://services.sentinel-hub.com/oauth/token';
        let currentPolygon = null;
        let currentImage = null;
        let currentImageOverlay = null;

        // Generate OAuth token
        const apiUrl = '   http://127.0.0.1:8000/fetch-token/';  // Your Django API endpoint for fetching the token

async function fetchTokenFromApi() {
    try {
        const response = await fetch(apiUrl, {
            method: 'GET',
            headers: {
                'Content-Type': 'application/json',
           

            }
        });

        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }

        const data = await response.json();

        if (data.token) {
            // Store the fetched token in localStorage without altering other data
            localStorage.setItem("token", data.token);
            console.log('Token fetched from API and stored in localStorage:', data.token);
            return data.token;
        } else {
            console.error('No token found in API response:', data);
        }
    } catch (error) {
        console.error('Error fetching token from API:', error);
    }
}
fetchTokenFromApi();
// Call the function to fetch and store the token every 10 seconds
setInterval(fetchTokenFromApi, 30 * 60 * 1000); // 30 minutes = 30 * 60 * 1000 ms



        // ===== UTILITY FUNCTIONS =====
        function showNotification(title, message, type = "info") {
            console.log(`${title}: ${message}`);
            
            // Remove existing notifications
            const existingNotifications = document.querySelectorAll('.notification');
            existingNotifications.forEach(notification => {
                notification.remove();
            });
            
            const notificationDiv = document.createElement('div');
            notificationDiv.className = `notification ${type}`;
            notificationDiv.innerHTML = `<strong>${title}</strong><br>${message}`;
            document.body.appendChild(notificationDiv);
            
            setTimeout(() => {
                if (notificationDiv.parentNode) {
                    notificationDiv.style.animation = 'slideIn 0.3s ease-out reverse';
                    setTimeout(() => {
                        notificationDiv.remove();
                    }, 300);
                }
            }, 4000);
        }

        function showError(message) {
            console.error(message);
            showNotification("Error", message, "error");
        }


        // Initialize map
      // Declare global variables for center coordinates
let centerLat = 32.33084;
let centerLon = 72.24750;


// Initialize map with attribution disabled
const map = L.map('map', {
    attributionControl: false
}).setView([33.444695, 73.173549], 19); // default center if no bbox

// Add Google Maps satellite + hybrid tiles
L.tileLayer('https://{s}.google.com/vt/lyrs=s,h&x={x}&y={y}&z={z}', {
    maxZoom: 20,
    minZoom: 4,
    subdomains: ['mt0', 'mt1', 'mt2', 'mt3']
}).addTo(map);

// Mapbox search function only
async function searchLocationWithMapbox(query, signal) {
  if (!query || query.length < 3) return []

  // Validate token first
  if (!MAPBOX_ACCESS_TOKEN || MAPBOX_ACCESS_TOKEN === "YOUR_MAPBOX_ACCESS_TOKEN_HERE") {
    throw new Error("Please configure your Mapbox access token")
  }

  try {
    const response = await fetch(
      `https://api.mapbox.com/search/geocode/v6/forward?q=${encodeURIComponent(query)}&proximity=ip&access_token=${MAPBOX_ACCESS_TOKEN}`,
      {
        headers: {
          "accept-language": "en-US",
        },
        signal: signal, // Use the passed signal
      },
    )

    if (!response.ok) {
      if (response.status === 401) {
        throw new Error("Invalid Mapbox access token")
      } else if (response.status === 429) {
        throw new Error("Rate limit exceeded. Please try again later")
      } else {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`)
      }
    }

    const data = await response.json()
    return data.features.map((feature) => ({
      id: feature.id,
      name: feature.properties.full_address || feature.properties.name,
      latitude: feature.geometry.coordinates[1],
      longitude: feature.geometry.coordinates[0],
      place_type: feature.properties.feature_type,
      context: feature.properties.context,
    }))
  } catch (error) {
    if (error.name === "AbortError") {
      console.log("Search request was aborted")
    } else {
      console.error("Failed to fetch geocoding data from Mapbox:", error)
    }
    throw error
  }
}

// Add responsive search control to map
function addResponsiveSearchControl() {
  const searchControl = L.Control.extend({
    options: {
      position: "topright",
    },
    onAdd: function (map) {
      this.map = map

      const container = L.DomUtil.create("div", "leaflet-control-search")

      container.innerHTML = `
                <div class="search-container" id="searchContainer">
                    <div class="search-icon" id="searchIcon" tabindex="0" role="button" aria-label="Open search">
                        <i class="fa fa-search" aria-hidden="true"></i>
                    </div>
                    <input 
                        type="text"
                        class="search-input"
                        id="locationSearch"
                        placeholder="Search for places, addresses..."
                        autocomplete="off"
                        autocorrect="off"
                        autocapitalize="off"
                        spellcheck="false"
                        aria-label="Search for locations"
                    >
                    <button class="search-clear" id="searchClear" aria-label="Clear search" tabindex="-1">
                        <i class="fa fa-times" aria-hidden="true"></i>
                    </button>
                    <div class="search-loading" id="searchLoading" aria-hidden="true"></div>
                </div>
                <div class="suggestions-container" id="suggestions" role="listbox" aria-label="Search suggestions"></div>
            `

      L.DomEvent.disableClickPropagation(container)
      L.DomEvent.disableScrollPropagation(container)

      this.initializeSearch(container)

      return container
    },

    initializeSearch: function (container) {
      const searchContainer = container.querySelector("#searchContainer")
      const searchIcon = container.querySelector("#searchIcon")
      const searchInput = container.querySelector("#locationSearch")
      const searchClear = container.querySelector("#searchClear")
      const searchLoading = container.querySelector("#searchLoading")
      const suggestionsContainer = container.querySelector("#suggestions")

      this.searchContainer = searchContainer
      this.searchIcon = searchIcon
      this.searchInput = searchInput
      this.searchClear = searchClear
      this.searchLoading = searchLoading
      this.suggestionsContainer = suggestionsContainer
      this.isExpanded = false
      this.currentRequest = null
      this.loadingTimeout = null // ✅ Add loading timeout tracking

      let searchTimeout

      // ✅ Improved debounced search function
      const debouncedSearch = debounce((query) => {
        this.handleLocationSearch(query)
      }, 300)

      const toggleSearch = () => {
        if (this.isExpanded) {
          this.collapseSearch()
        } else {
          this.expandSearch()
        }
      }

      searchIcon.addEventListener("click", toggleSearch)
      searchIcon.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault()
          toggleSearch()
        }
      })

      const clearSearch = () => {
        searchInput.value = ""
        searchClear.style.display = "none"
        suggestionsContainer.classList.remove("show")
        searchInput.focus()
        this.hideLoading() // ✅ Ensure loading is hidden
      }

      searchClear.addEventListener("click", clearSearch)
      searchClear.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault()
          clearSearch()
        }
      })

      // ✅ Improved input handling with better loading management
      searchInput.addEventListener("input", (e) => {
        const query = e.target.value.trim()

        // Show/hide clear button
        searchClear.style.display = query ? "flex" : "none"
        searchClear.tabIndex = query ? "0" : "-1"

        // ✅ Cancel previous request and clear loading
        if (this.currentRequest) {
          this.currentRequest.abort()
          this.currentRequest = null
        }

        // ✅ Clear any pending loading timeout
        if (this.loadingTimeout) {
          clearTimeout(this.loadingTimeout)
          this.loadingTimeout = null
        }

        // ✅ Hide loading immediately when clearing or short query
        if (!query || query.length < 3) {
          suggestionsContainer.classList.remove("show")
          this.hideLoading()
          return
        }

        // ✅ Show loading with delay, but track the timeout
        this.loadingTimeout = setTimeout(() => {
          // Only show loading if the query hasn't changed and is still valid
          if (searchInput.value.trim() === query && query.length >= 3 && !this.currentRequest) {
            this.showLoading()
          }
          this.loadingTimeout = null
        }, 150)

        // Debounce search
        debouncedSearch(query)
      })

      // Handle keyboard events
      searchInput.addEventListener("keydown", (e) => {
        const suggestions = suggestionsContainer.querySelectorAll(".suggestion-item")
        const activeSuggestion = suggestionsContainer.querySelector(".suggestion-item.active")

        switch (e.key) {
          case "Escape":
            this.collapseSearch()
            break
          case "ArrowDown":
            e.preventDefault()
            this.navigateSuggestions(suggestions, activeSuggestion, "down")
            break
          case "ArrowUp":
            e.preventDefault()
            this.navigateSuggestions(suggestions, activeSuggestion, "up")
            break
          case "Enter":
            e.preventDefault()
            if (activeSuggestion) {
              activeSuggestion.click()
            }
            break
          case "Tab":
            if (!e.shiftKey && activeSuggestion) {
              e.preventDefault()
              activeSuggestion.click()
            }
            break
        }
      })

      searchInput.addEventListener("focus", () => {
        if (searchInput.value.trim().length >= 3) {
          suggestionsContainer.classList.add("show")
        }
      })

      document.addEventListener("click", (e) => {
        if (!container.contains(e.target) && this.isExpanded) {
          this.collapseSearch()
        }
      })

      window.addEventListener(
        "resize",
        debounce(() => {
          if (this.isExpanded && isMobileDevice()) {
            this.adjustMobileLayout()
          }
        }, 250),
      )
    },

    expandSearch: function () {
      this.searchContainer.classList.add("expanded")
      this.searchInput.classList.add("show")
      this.searchIcon.setAttribute("aria-label", "Close search")

      setTimeout(() => {
        this.searchInput.focus()
      }, 100)

      this.isExpanded = true

      if (isMobileDevice()) {
        this.adjustMobileLayout()
      }
    },

    collapseSearch: function () {
      this.searchContainer.classList.remove("expanded")
      this.searchInput.classList.remove("show")
      this.suggestionsContainer.classList.remove("show")
      this.searchClear.style.display = "none"
      this.searchClear.tabIndex = "-1"
      this.searchIcon.setAttribute("aria-label", "Open search")
      this.hideLoading() // ✅ Always hide loading when collapsing
      this.isExpanded = false

      // ✅ Cancel any pending requests and timeouts
      if (this.currentRequest) {
        this.currentRequest.abort()
        this.currentRequest = null
      }

      if (this.loadingTimeout) {
        clearTimeout(this.loadingTimeout)
        this.loadingTimeout = null
      }
    },

    adjustMobileLayout: function () {
      const viewport = window.visualViewport
      if (viewport) {
        const keyboardHeight = window.innerHeight - viewport.height
        if (keyboardHeight > 150) {
          this.suggestionsContainer.style.maxHeight = `${Math.max(200, viewport.height * 0.3)}px`
        } else {
          this.suggestionsContainer.style.maxHeight = ""
        }
      }
    },

    // ✅ Improved loading management
    showLoading: function () {
      this.searchLoading.style.display = "block"
      this.searchClear.style.display = "none"
      this.searchContainer.classList.add("loading")
    },

    hideLoading: function () {
      this.searchLoading.style.display = "none"
      this.searchContainer.classList.remove("loading")

      // ✅ Only show clear button if there's text
      if (this.searchInput.value.trim()) {
        this.searchClear.style.display = "flex"
        this.searchClear.tabIndex = "0"
      }
    },

    // ✅ Improved search handling with better loading management
    handleLocationSearch: async function (query) {
      try {
        // ✅ Create abort controller for this specific request
        this.currentRequest = new AbortController()

        // ✅ Clear any pending loading timeout since we're starting a real request
        if (this.loadingTimeout) {
          clearTimeout(this.loadingTimeout)
          this.loadingTimeout = null
        }

        // ✅ Show loading immediately when starting actual search
        this.showLoading()

        // ✅ Pass the abort signal to the search function
        const suggestions = await searchLocationWithMapbox(query, this.currentRequest.signal)

        // ✅ Check if request was aborted before processing results
        if (this.currentRequest && this.currentRequest.signal.aborted) {
          return
        }

        // ✅ Hide loading before displaying results
        this.hideLoading()
        this.displaySuggestions(suggestions, query)
      } catch (error) {
        // ✅ Always hide loading on error (unless aborted)
        if (error.name !== "AbortError") {
          console.error("Search error:", error)
          this.hideLoading()
          this.showSearchError(error.message)
        }
        // ✅ Don't hide loading for AbortError as it's handled elsewhere
      } finally {
        // ✅ Clean up current request reference
        if (this.currentRequest && !this.currentRequest.signal.aborted) {
          this.currentRequest = null
        }
      }
    },

    displaySuggestions: function (suggestions, query) {
      this.suggestionsContainer.innerHTML = ""
      this.suggestionsContainer.setAttribute("aria-live", "polite")

      if (suggestions.length === 0) {
        const noResults = document.createElement("div")
        noResults.className = "no-results"
        noResults.innerHTML = `
                    <i class="fa fa-search" aria-hidden="true"></i>
                    <div class="no-results-text">No locations found</div>
                    <div class="no-results-subtext">Try a different search term</div>
                `
        this.suggestionsContainer.appendChild(noResults)
        this.suggestionsContainer.classList.add("show")
        return
      }

      suggestions.forEach((suggestion, index) => {
        const suggestionItem = document.createElement("div")
        suggestionItem.className = "suggestion-item"
        suggestionItem.setAttribute("role", "option")
        suggestionItem.setAttribute("tabindex", "-1")
        suggestionItem.setAttribute("aria-label", `${suggestion.name}, ${suggestion.place_type}`)

        const icon = this.getPlaceIcon(suggestion.place_type)

        suggestionItem.innerHTML = `
                    <div class="suggestion-icon" aria-hidden="true">
                        <i class="fa ${icon}"></i>
                    </div>
                    <div class="suggestion-content">
                        <div class="suggestion-name">${this.highlightQuery(suggestion.name, query)}</div>
                        <div class="suggestion-type">${suggestion.place_type || "location"}</div>
                    </div>
                `

        suggestionItem.addEventListener("click", () => {
          this.selectLocation(suggestion)
        })

        suggestionItem.addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault()
            this.selectLocation(suggestion)
          }
        })

        suggestionItem.addEventListener("mouseenter", () => {
          this.setActiveSuggestion(suggestionItem)
        })

        this.suggestionsContainer.appendChild(suggestionItem)
      })

      this.suggestionsContainer.classList.add("show")

      const resultCount = suggestions.length
      this.suggestionsContainer.setAttribute(
        "aria-label",
        `${resultCount} search result${resultCount !== 1 ? "s" : ""} available`,
      )
    },

    showSearchError: function (errorMessage) {
      this.suggestionsContainer.innerHTML = `
                <div class="search-error">
                    <i class="fa fa-exclamation-triangle" aria-hidden="true"></i>
                    <div class="error-text">${errorMessage}</div>
                </div>
            `
      this.suggestionsContainer.classList.add("show")
    },

    highlightQuery: (text, query) => {
      if (!query || query.length < 2) return text

      const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")})`, "gi")
      return text.replace(regex, "<mark>$1</mark>")
    },

    setActiveSuggestion: function (suggestionItem) {
      this.suggestionsContainer.querySelectorAll(".suggestion-item").forEach((item) => {
        item.classList.remove("active")
        item.setAttribute("tabindex", "-1")
      })
      suggestionItem.classList.add("active")
      suggestionItem.setAttribute("tabindex", "0")
    },

    selectLocation: function (suggestion) {
      if (navigator.vibrate && isMobileDevice()) {
        navigator.vibrate(50)
      }

      this.map.setView([suggestion.latitude, suggestion.longitude], 15)

      this.map.eachLayer((layer) => {
        if (layer.options && layer.options.searchMarker) {
          this.map.removeLayer(layer)
        }
      })

      const marker = L.marker([suggestion.latitude, suggestion.longitude], {
        searchMarker: true,
      }).addTo(this.map)

      marker
        .bindPopup(`
                    <div style="text-align: center; min-width: 200px; font-family: 'Inter', sans-serif;">
                        <div style="font-weight: 600; color: #1f2937; margin-bottom: 8px; font-size: 16px;">
                            ${suggestion.name}
                        </div>
                        <div style="color: #6b7280; font-size: 12px; margin-bottom: 8px; text-transform: capitalize;">
                            ${suggestion.place_type || "Location"}
                        </div>
                        <div style="color: #9ca3af; font-size: 11px; font-family: monospace;">
                            ${suggestion.latitude.toFixed(6)}, ${suggestion.longitude.toFixed(6)}
                        </div>
                    </div>
                `)
        .openPopup()

      this.searchInput.value = ""
      this.collapseSearch()

      const announcement = `Selected ${suggestion.name}`
      const ariaLive = document.createElement("div")
      ariaLive.setAttribute("aria-live", "polite")
      ariaLive.setAttribute("aria-atomic", "true")
      ariaLive.style.position = "absolute"
      ariaLive.style.left = "-10000px"
      ariaLive.textContent = announcement
      document.body.appendChild(ariaLive)
      setTimeout(() => document.body.removeChild(ariaLive), 1000)
    },

    getPlaceIcon: (placeType) => {
      const iconMap = {
        address: "fa-home",
        poi: "fa-map-marker-alt",
        place: "fa-map-pin",
        locality: "fa-city",
        neighborhood: "fa-building",
        street: "fa-road",
        country: "fa-flag",
        region: "fa-map",
        postcode: "fa-mail-bulk",
        district: "fa-map-marked-alt",
        restaurant: "fa-utensils",
        hospital: "fa-hospital",
        school: "fa-school",
        park: "fa-tree",
        hotel: "fa-bed",
        gas_station: "fa-gas-pump",
        bank: "fa-university",
        shop: "fa-shopping-cart",
      }

      return iconMap[placeType] || "fa-map-marker-alt"
    },

    navigateSuggestions: (suggestions, activeSuggestion, direction) => {
      if (suggestions.length === 0) return

      if (activeSuggestion) {
        activeSuggestion.classList.remove("active")
        activeSuggestion.setAttribute("tabindex", "-1")
      }

      let nextIndex = 0
      if (activeSuggestion) {
        const currentIndex = Array.from(suggestions).indexOf(activeSuggestion)
        if (direction === "down") {
          nextIndex = (currentIndex + 1) % suggestions.length
        } else {
          nextIndex = currentIndex === 0 ? suggestions.length - 1 : currentIndex - 1
        }
      }

      const nextSuggestion = suggestions[nextIndex]
      nextSuggestion.classList.add("active")
      nextSuggestion.setAttribute("tabindex", "0")
      nextSuggestion.scrollIntoView({ block: "nearest", behavior: "smooth" })

      const announcement = nextSuggestion.getAttribute("aria-label")
      nextSuggestion.setAttribute("aria-live", "polite")
      setTimeout(() => nextSuggestion.removeAttribute("aria-live"), 100)
    },
  })

  return new searchControl()
}

// ✅ Utility function for debouncing
function debounce(func, wait) {
  let timeout
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout)
      func(...args)
    }
    clearTimeout(timeout)
    timeout = setTimeout(later, wait)
  }
}

// ✅ Utility function to detect mobile devices
function isMobileDevice() {
  return window.innerWidth <= 768
}

   const searchControl = addResponsiveSearchControl()
map.addControl(searchControl)   

            // Show welcome message
            setTimeout(() => {
                showNotification("Welcome!", "Click the search icon in the top-right to search for locations", "info");
            }, 1000);

// ✅ Load bbox from localStorage and fit map to it
const savedBBox = localStorage.getItem("polygonBBox");
if (savedBBox) {
    try {
        const parsedBBox = JSON.parse(savedBBox);  // [[southWest], [northEast]]
        const bounds = L.latLngBounds(parsedBBox);
        map.fitBounds(bounds);
    } catch (err) {
        console.error("Error parsing bbox:", err);
    }
}


// // // Function to fetch the bounding box and update global centerLat and centerLon
// // async function fetchBoundingBox() {
// //   try {
// //    const response = await fetch('   http://127.0.0.1:8000/get-bbox/', {
// //     method: 'GET',
// //     headers: {
// //         'ngrok-skip-browser-warning': 'true'
// //     }
// // });


//     if (!response.ok) {
//       throw new Error('Failed to fetch bounding box data');
//     }

//     const data = await response.json();

//     if (data.status === 'success') {
//       const minLat = data.bbox.min_latitude;
//       const minLon = data.bbox.min_longitude;
//       const maxLat = data.bbox.max_latitude;
//       const maxLon = data.bbox.max_longitude;

//       // Update the global center variables
//       centerLat = (minLat + maxLat) / 2;
//       centerLon = (minLon + maxLon) / 2;

//       // Update the map's view with the new center
//       map.setView([centerLat, centerLon], 15);

//       console.log('Global center updated to:', centerLat, centerLon);
//     } else {
//       console.error('Error fetching bounding box:', data.message);
//     }
//   } catch (error) {
//     console.error('Error fetching bounding box:', error);
//   }
// }

// // Call the function to fetch the bounding box and update the center
// fetchBoundingBox();



        // Initialize draw controls
        const drawnItems = new L.FeatureGroup();
        map.addLayer(drawnItems);

 
const drawControl = new L.Control.Draw({
    edit: { 
        featureGroup: drawnItems,
        remove: true
    },
    draw: {
        polygon: {
            allowIntersection: false,
            drawError: {
                color: '#e1e100',
                timeout: 1000
            },
            shapeOptions: {
                color: '#4CAF50'
            }
        },
        rectangle: true,
        polygon: false,
        circle: false,
        circlemarker: false,
        marker: false,
        polyline: false
    }
});

map.addControl(drawControl);



// Listen for when a shape is drawn on the map
map.on('draw:created', function(e) {
    const layer = e.layer;

    // Add the drawn layer to the drawnItems group
    drawnItems.addLayer(layer);

    // Set a timeout to remove the drawn item after 10 seconds
    setTimeout(() => {
        drawnItems.clearLayers();  // Clears all layers in the drawnItems feature group
    }, 1000);  // 10000ms = 10 seconds
});


       
        map.on('draw:created', async function(e) {
    drawnItems.clearLayers();
    currentPolygon = e.layer;
    drawnItems.addLayer(currentPolygon);
    const loadingIndicator = document.getElementById('loadingIndicator');

    const coords = currentPolygon.getLatLngs()[0].map(point => [point.lng, point.lat]);
    const bbox = getBoundingBox(coords);

    try {
        loadingIndicator.style.display = 'block';

        // Step 1: Fetch dates first
        console.log("Fetching available dates...");
        const datesResponse = await fetchSentinel2Data(bbox);

        if (!datesResponse || !datesResponse.features || datesResponse.features.length === 0) {
            throw new Error("No available dates found for the selected area.");
        }

        // Extract available dates and populate the dropdown
        const availableDates = datesResponse.features.map(feature => feature.properties.datetime);
        console.log("Available Dates:", availableDates);
        populateDateDropdown(availableDates);

        // Step 2: Wait for user to select a date
        const selectedDate = await waitForDateSelection();
        console.log("User selected date:", selectedDate);

        // Step 3: Fetch the Sentinel image for the selected date
        console.log(`Fetching Sentinel image for ${selectedDate}...`);
        let image = await fetchSentinelImage(bbox, coords, selectedDate);

        if (image) {
            console.log("Image successfully fetched.");
            currentImage = image;

            // Step 4: Display the adjusted image
            await displayAdjustedImage(image);
            console.log("Image displayed with adjustments.");
        } else {
            console.error("Failed to fetch the image.");
            alert("No image available for the selected date.");
        }
    } catch (error) {
        console.error('Error processing request:', error);
        alert('An error occurred while processing your request. Please try again.');
    } finally {
        loadingIndicator.style.display = 'none';
    }
});
function waitForDateSelection() {
    return new Promise((resolve) => {
        const dropdown = document.getElementById('dateDropdown');
        dropdown.addEventListener('change', function handler(event) {
            dropdown.removeEventListener('change', handler);
            resolve(event.target.value);  // Return the selected date
        });
    });
}

       
async function fetchSentinel2Data(bbox) {
    console.log("Fetching Sentinel-2 L2A data for bbox:", bbox);
    let token = localStorage.getItem("token");
    const apiUrl = `https://services.sentinel-hub.com/api/v1/catalog/1.0.0/search`;

    // Generate current date dynamically
    const currentDate = new Date();
    const currentDateISOString = currentDate.toISOString(); // Format: "YYYY-MM-DDTHH:MM:SSZ"

    // Set the start date to January 1, 2013
    const startDate = "2022-01-01T00:00:00Z";  // Start date from 2013

    // Create datetime range: Start from Jan 1, 2013, to the current date
    const datetimeRange = `${startDate}/${currentDateISOString}`;

   const requestBody = {
    bbox: bbox,  // Fix here
    datetime: "2020-01-01T00:00:00Z/" + new Date().toISOString(),
    limit: 100,
    collections: ["sentinel-2-l1c"],
    "filter-lang": "cql2-text",
    filter: "eo:cloud_cover < 30"
};


    try {
        const response = await fetch(apiUrl, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${token}`
            },
            body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
            const errorData = await response.text();
            console.error('Error fetching Sentinel-2 L2A data:', errorData);
            return null;
        }

        const data = await response.json();
        
        // Log the fetched data
        console.log("Fetched Sentinel-2 L2A data:", data);

        // Extracting and logging dates from the response
        if (data && data.features) {
            const dates = data.features.map(feature => feature.properties.datetime);
            console.log("Available Dates:", dates);

            // Call function to populate the dropdown with dates
            populateDateDropdown(dates);
        }

        return data;
    } catch (error) {
        console.error('Error fetching Sentinel-2 L2A data:', error);
        return null;
    }
}



// Function to populate the dropdown with dates
async function populateDateDropdown(dates) {
    const dropdown = document.getElementById('dateDropdown');

    // Clear existing options (if any)
    dropdown.innerHTML = '';

    // Add each date as an option in the dropdown
    dates.forEach(date => {
        const option = document.createElement('option');
        option.value = date;
        option.text = new Date(date).toLocaleDateString(); // Format the date as needed
        dropdown.appendChild(option);
    });

    if (dates.length > 0) {
        // Automatically select the first date
        dropdown.selectedIndex = 0;

        const firstDate = dates[0];
        console.log("Automatically fetching image for the first available date:", firstDate);

        try {
            // Ensure bbox and geometry exist before calling fetchSentinelImage
            if (!currentPolygon) {
                console.error("No polygon selected.");
                alert("Please draw a polygon on the map.");
                return;
            }

            const coords = currentPolygon.getLatLngs()[0].map(point => [point.lng, point.lat]);
            const bbox = getBoundingBox(coords);

            // Fetch the image for the first date
            const imageBlob = await fetchSentinelImage(bbox, coords, firstDate);
            if (imageBlob) {
                console.log("Sentinel image fetched successfully for the first date.");
                
                // Store the fetched image in currentImage
                currentImage = imageBlob;

                // Display the image with adjustments applied
                displayAdjustedImage(currentImage);
            } else {
                console.error("No image returned from Sentinel API.");
            }
        } catch (error) {
            console.error("Error fetching Sentinel image for the first date:", error);
        }
    }
}



        function continueSelectedDate() {
    const dropdown = document.getElementById('dateDropdown');
    const selectedDate = localStorage.getItem('selectedDate'); // Retrieve the previously selected date from localStorage

    if (selectedDate) {
        const options = dropdown.getElementsByTagName('option');
        
        // Loop through all options in the dropdown and select the matching one
        for (let option of options) {
            if (option.value === selectedDate) {
                option.selected = true;  // Mark the option as selected
                break;  // Exit the loop once the correct option is found
            }
        }
    }
}
// Add an event listener to store the selected date in localStorage when the user selects a new date
document.getElementById('dateDropdown').addEventListener('change', async function(event) {
    const selectedDate = event.target.value;
    console.log("User selected date:", selectedDate);

    // Store the selected date in localStorage
    localStorage.setItem('selectedDate', selectedDate);

    // Ensure bbox and geometry exist before calling fetchSentinelImage
    if (!currentPolygon) {
        console.error("No polygon selected.");
        alert("Please draw a polygon on the map before selecting a date.");
        return;
    }

    const coords = currentPolygon.getLatLngs()[0].map(point => [point.lng, point.lat]);
    const bbox = getBoundingBox(coords);

    try {
        const imageBlob = await fetchSentinelImage(bbox, coords, selectedDate);
        if (imageBlob) {
            console.log("Sentinel image fetched successfully.");
            displayAdjustedImage(imageBlob);
        } else {
            console.error("No image returned from Sentinel API.");
        }
    } catch (error) {
        console.error("Error fetching Sentinel image:", error);
    }
});




async function fetchSentinelImage(bbox, geometry, selectedDate) {
    // Fetch the token from localStorage
    let token = localStorage.getItem("token");

    // If the token is not found, call fetchSentinelKey() to generate and store a new one
    if (!token) {
        console.log('Token not found, generating a new one...');
        await fetchSentinelKey(); // This will store the token in localStorage
        token = localStorage.getItem("token"); // Retrieve the newly stored token
    }

    // If token is still not found, throw an error
    if (!token) {
        throw new Error('Failed to get authorization token');
    }

    console.log('Using token:', token);

    // Validate the selectedDate and make sure it's in the right format
    const date = new Date(selectedDate);
    if (isNaN(date.getTime())) {
        throw new Error('Invalid selected date format');
    }

    // Ensure that selectedDate is formatted in ISO 8601 with zeroed time component for API use
    const formattedDate = date.toISOString().split('T')[0]; // "YYYY-MM-DD"

    // Use the selectedDate to set the timeRange for the API request
    const requestBody = {
        input: {
            bounds: {
                bbox: bbox,
                properties: { crs: "http://www.opengis.net/def/crs/EPSG/0/4326" }
            },
            data: [{
                type: "sentinel-2-l2a",
                dataFilter: {
                    timeRange: { 
                        from: `${formattedDate}T00:00:00Z`, 
                        to: `${formattedDate}T23:59:59Z` 
                    },
                    mosaickingOrder: "leastCC"
                }
            }]
        },
        output: {
            responses: [{
                identifier: "default",
                format: { type: "image/png" }
            }]
        },
        resampling: "BICUBIC", 
        evalscript: `
            //VERSION=3
            function setup() {
                return {
                    input: ["B04", "B03", "B02"],
                    output: { bands: 3, sampleType: "AUTO" }
                };
            }
            function evaluatePixel(sample) {
                return [sample.B04, sample.B03, sample.B02];
            }
        `
    };

    // Make the API request to fetch the image
    const response = await fetch('https://services.sentinel-hub.com/api/v1/process', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${token}` // Use the token in the Authorization header
        },
        body: JSON.stringify(requestBody)
    });

    // Check for HTTP errors
    if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`HTTP error! status: ${response.status} - ${errorText}`);
    }

    // Return the image data as a Blob
    return await response.blob();
   
}


        function getBoundingBox(coordinates) {
            const lngs = coordinates.map(coord => coord[0]);
            const lats = coordinates.map(coord => coord[1]);
            return [
                Math.min(...lngs),
                Math.min(...lats),
                Math.max(...lngs),
                Math.max(...lats)
            ];
        }
        
                   
               

        async function displayAdjustedImage(imageBlob) {
    const brightness = parseFloat(document.getElementById('brightness').value);
    const contrast = parseFloat(document.getElementById('contrast').value);
    const equalizer = parseInt(document.getElementById('equalizer').value);

    let adjustedImage = await adjustBrightnessContrast(imageBlob, brightness, contrast);
    
    if (equalizer === 1) {
        adjustedImage = await histogramEqualize(adjustedImage);
    }

    if (currentImageOverlay) {
        map.removeLayer(currentImageOverlay);
    }

    const imageUrl = URL.createObjectURL(adjustedImage);
    currentImageOverlay = L.imageOverlay(imageUrl, currentPolygon.getBounds()).addTo(map);
}

function adjustBrightnessContrast(imageBlob, brightness, contrast) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        img.onload = () => {
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                data[i] = data[i] * brightness;
                data[i + 1] = data[i + 1] * brightness;
                data[i + 2] = data[i + 2] * brightness;

                for (let j = 0; j < 3; j++) {
                    const channel = i + j;
                    data[channel] = ((data[channel] - 128) * contrast) + 128;
                    data[channel] = Math.min(255, Math.max(0, data[channel]));
                }
            }

            ctx.putImageData(imageData, 0, 0);
            canvas.toBlob((blob) => resolve(blob), 'image/png');
        };

        img.onerror = reject;
        img.src = URL.createObjectURL(imageBlob);
    });
}

function histogramEqualize(imageBlob) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        img.onload = () => {
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            const histogram = new Array(256).fill(0);
            for (let i = 0; i < data.length; i += 4) {
                const luminance = Math.floor(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);
                histogram[luminance]++;
            }

            const cumulativeHistogram = new Array(256).fill(0);
            cumulativeHistogram[0] = histogram[0];
            for (let i = 1; i < 256; i++) {
                cumulativeHistogram[i] = cumulativeHistogram[i - 1] + histogram[i];
            }

            const totalPixels = data.length / 4;
            const scaleFactor = 255 / totalPixels;

            for (let i = 0; i < data.length; i += 4) {
                const luminance = Math.floor(0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2]);
                const equalizedValue = Math.floor(cumulativeHistogram[luminance] * scaleFactor);

                data[i] = data[i + 1] = data[i + 2] = equalizedValue;
            }

            ctx.putImageData(imageData, 0, 0);
            canvas.toBlob((blob) => resolve(blob), 'image/png');
        };

        img.onerror = reject;
        img.src = URL.createObjectURL(imageBlob);
    });
}

        const toggleControlsButton = document.getElementById('toggleControls');
const controlPanel = document.getElementById('controlPanel');

// Initially hide the control panel
controlPanel.style.maxHeight = '0';

toggleControlsButton.addEventListener('click', () => {
    const isPanelOpen = controlPanel.style.maxHeight !== '0px';
    
    if (isPanelOpen) {
        controlPanel.style.maxHeight = '0';
        toggleControlsButton.classList.remove('active');
        toggleControlsButton.textContent = 'Menu';
    } else {
        controlPanel.style.maxHeight = controlPanel.scrollHeight + 'px';
        toggleControlsButton.classList.add('active');
        toggleControlsButton.textContent = 'Hide Menu';
    }
});

        document.getElementById('brightness').addEventListener('input', () => displayAdjustedImage(currentImage));
        document.getElementById('contrast').addEventListener('input', () => displayAdjustedImage(currentImage));
        document.getElementById('equalizer').addEventListener('input', () => displayAdjustedImage(currentImage));
        document.getElementById('resetControls').addEventListener('click', () => {
            document.getElementById('brightness').value = 1.0;
            document.getElementById('contrast').value = 1.0;
            document.getElementById('equalizer').value = 0;
            displayAdjustedImage(currentImage);
        });




        let imageVisible = true;

document.getElementById('toggleImage').addEventListener('click', () => {
    if (currentImageOverlay) {
        if (imageVisible) {
            map.removeLayer(currentImageOverlay);
            document.getElementById('toggleImage').textContent = "Show";
        } else {
            map.addLayer(currentImageOverlay);
            document.getElementById('toggleImage').textContent = "Compare";
        }
        imageVisible = !imageVisible;
    } else {
        alert("No image available to toggle. Please fetch an image first.");
    }
});

    </script>
   
</body>
</html>
